(* feature.ml *)

open Common

type strand = | Forward  
              | Reverse
	      | Unstranded
	      | Unknown


let strand_of_string s =
  match s with
    | "++"
    | "+" -> Forward
    | "+-"
    | "-" -> Reverse
    | "." -> Unstranded
    | "?" -> Unknown
    |  _  -> failwith "strand_of_string : the strand should be provided as the 7th field of your gtf file\n" 


let strand_to_string = function
  | Forward -> "+"
  | Reverse -> "-"
  | Unstranded -> "."
  | Unknown -> "?"


let strand_to_string2 = function
  | Forward -> "p"
  | Reverse -> "m"
  | Unstranded -> "."
  | Unknown -> "?"



(* Takes a string v and checks whether it represents a fdd value field = be an integer, is greater than 10 and even *)
let is_gff_value_field v =
  let i = int_of_string v in
    ((i>=10) && ((i mod 2)==0));;
      
  
(* From a string of what we hope are integers that are more than 10 and even separated by commas,
   get a list of such integers.
   Raise a failure if one of those conditions is not met since these values would not then 
   correspond to gff value fields. *)
let get_list_of_gff_value_field s =
  let lval = split ',' s in
    if (List.for_all is_gff_value_field lval) then
      lval
    else
      begin
	failwith "with the -m n option and when n is not an integer, n has to be a list of integers greater than 10 and even, separated by commas\n"; 
	[]
      end;;
    
    
(* Corresponding to a personalized type of gff format with tabulations first and then a list of attributes
   formatted as (key,value).*)
module Feature =
struct
  type t = {
    seq: string;                      (* in 1st field in gffflex *)
    start: int;                       (* in 4th field in gffflex *)
    stop: int;                        (* in 5th field in gffflex *)
    str: strand;                      (* in 7th field in gffflex *)
    ftype: string;                    (* in 3rd field in gffflex *)
    source: string;                   (* in 2nd field in gffflex *)
    score: string;                    (* in 6th field in gffflex *)
    frame: string;                    (* in 8th field in gffflex
					 in fact could only be . or 0 or 1 or 2, and these 3 only in case of CDS feature 
				      *)
    attlist: (string * string) list   (* in 9th field in gffflex
					 a list of attributes of the form (key, value) 
				      *) 
  }

  let create seq sta sto str ft src sc fr al = 
    {seq=seq; start=sta; stop=sto; str=str; ftype=ft; source=src; score=sc; frame=fr; attlist=al}
  
  let null = create "" (-1) (-1) Unstranded "null" "null" "." "." []
  let isnull f = (f=null)
    
  let compare_coord f1 f2 = 
    if ((Pervasives.compare f1.seq f2.seq)!=0) then
      Pervasives.compare f1.seq f2.seq
    else
      begin
	if ((Pervasives.compare f1.start f2.start)!=0) then
	  Pervasives.compare f1.start f2.start
	else
	  Pervasives.compare f1.stop f2.stop
      end

  let interval f = (f.start,f.stop)   
  let setattlist al f = {f with attlist=al}

  let to_non_null_string v=
    if (v="") then
      "."
    else
      v

  (* checks whether the value v of a gff (key,value) pair is bordered by two double quotes and a semicolon 
     and if this is not the case adds some *)
  let value_to_ucsc_value v = 
    let n=String.length v in
      try
	(
	  if (((String.get v 0)='"') && ((String.sub v (n-2) 2)="\";")) then
	    v
	  else
	    ("\"")^(v)^("\";")
	)
      with 
	  Invalid_argument _ -> ("\"")^(v)^("\";")

  (* makes a string for gff flex output from a feature attribute list
     note that it takes as input the ucsc boolean option, which if it is true
     is the fact of adding two double quotes and one semi colon to each value that does not already have them 
  *)
  let string_attlist_in_gff_flex ucsc f = 
    let s= ref "" in
      (* note that here we are adding a space at the end of each line, that is why we do clean_end_string *)
      if (ucsc) then
	List.iter (fun (k,v) -> s:=(!s)^(" ")^(k)^(" ")^(value_to_ucsc_value (to_non_null_string v))) f.attlist
      else
	List.iter (fun (k,v) -> s:=(!s)^(" ")^(k)^(" ")^((to_non_null_string v))) f.attlist;
      (clean_end_string !s)
	
	    

  (* print_gff_flex takes as input:
     - o which is the output channel corresponding to the file where we need to write file1 with overlap info 
     - u which is the boolean ucsc printing option = we add two double quotes and one semi colon to all values of a pair (key,value)
       when this is not already the case (will modify all the values of the output file, even those that were not generated by overlap)
     - f which is a feature
     and prints in o the feature in the gff flexible format.
  *)
  let print_gff_flex o ucsc f =
    Printf.fprintf o "%s\t%s\t%s\t%i\t%i\t%s\t%s\t%s\t%s\n" f.seq f.source f.ftype f.start f.stop f.score (strand_to_string f.str) f.frame (string_attlist_in_gff_flex ucsc f)

  let isplus f = match f.str with
    | Forward -> true
    | _ -> false
  let isminus f = match f.str with
    | Reverse -> true
    | _ -> false
  let isplusorminus f = match f.str with
    | Forward | Reverse -> true
    | _ -> false
  let issamestr str f = (f.str=str)
    (* having different strands is only valid for + or - strand features *)
  let isdiffstr str f = (((str=Forward)||(str=Reverse))&&(isplusorminus f)&&(f.str!=str))
  
  let interval f = (f.start,f.stop)

  let intersection f1 f2 =
    if (f1.seq=f2.seq) then
      ((max f1.start f2.start), (min f1.stop f2.stop))
    else
      raise (Invalid_argument "intersection")

  (* f1 generally (not stricly) included in f2 *)
  let inclusion f1 f2 =
    if (f1.seq=f2.seq) then
      Common.finclusion (interval f1) (interval f2)
    else
      raise (Invalid_argument "inclusion")
  
    
  let seq f = f.seq
  let start f = f.start
  let stop f = f.stop
  let str f = f.str
  let ftype f = f.ftype
  let source f = f.source
  let score f = f.score
  let frame f = f.frame
  let attlist f = f.attlist
end





module Exon =
struct
  type t = {
	chrom: string;
	gbeg: int;
	gend: int;
	str: strand;
	score: float;
	cat: string;
	trid: string;
	gnid: string;
  }

  let create chr gb ge st sc ct tr gn = { chrom=chr; gbeg=gb; gend=ge; str=st; score= sc; cat=ct; trid=tr; gnid=gn}
  let null = create "" (-1) (-1) Forward  0.0 "" "" ""

  (* when we compare two exons we compare them by gene first *)
  let compare e1 e2 = 
    if ((Pervasives.compare e1.gnid e2.gnid) !=0) then
      Pervasives.compare e1.gnid e2.gnid
    else
      begin
	if ((Pervasives.compare e1.gbeg e2.gbeg) !=0) then
	  Pervasives.compare e1.gbeg e2.gbeg
	else
	  Pervasives.compare e1.gend e2.gend
      end
    
  let chrom e = e.chrom
  let gbeg e = e.gbeg
  let gend e = e.gend
  let str e = e.str
  let score e = e.score
  let cat e = e.cat
  let trid e = e.trid
  let gnid e = e.gnid
end 


module Transcript =
struct
  type t = {
	chrom: string;
	gbeg: int;
	gend: int;
	str: strand;
	cat: string;
	exlist: Exon.t list;
	trid: string;
	gnid: string;
  }
	  
  let create chr gb ge st ct el tr gn = 
    { chrom=chr; gbeg=gb; gend=ge; str=st; cat=ct;  exlist=el; trid=tr; gnid=gn}

  let chrom t = t.chrom
  let gbeg t = t.gbeg
  let gend t = t.gend
  let str t = t.str	
  let cat t = t.cat
  let exlist t = t.exlist
  let trid t = t.trid
  let gnid t = t.gnid
end



module Gene = 
struct
  type t = {
	chrom: string;
	gbeg: int;
	gend: int;
	str: strand;
	trarr: Transcript.t array;
	exarr: Exon.t array;
	gnid: string;
  }

  let create chr gb ge st ta ea gn = 
    { chrom=chr; gbeg=gb; gend=ge; str=st; trarr=ta; exarr= ea; gnid=gn}
	  
  let chrom g = g.chrom
  let gbeg g = g.gbeg
  let gend g = g.gend
  let str g = g.str	
  let trarr g = g.trarr
  let exarr g = g.exarr
  let gnid g = g.gnid
end



(* Exon projection. In a gene it is a maximal set of overlapping exons *)
module ExonProj =
struct
  type t = {
	chrom: string;
	gbeg: int;
	gend: int;
	str: strand;
	nbex: int;  (* number of exons if is made of *)
	exarr: Exon.t array;  (* The exons it is made of *)
	noingn: int;    (* number of the exon projection among all the exon projections of the gene (from 5') *)
	begingn: int;   (* begining of the exon projection in the virtual cDNA made by joining all the exon projections of the gene *)
	endingn: int;   (* end of the exon projection in the virtual cDNA made by joining all the exon projections of the gene *)
 }
	  
  let create chr gb ge st ne ea no bgn egn = 
    { chrom=chr; gbeg=gb; gend=ge; str=st; nbex=ne; exarr=ea; noingn=no; begingn=bgn; endingn=egn}
  
  let chrom e = e.chrom
  let gbeg e = e.gbeg
  let gend e = e.gend
  let str e = e.str
  let nbex e = e.nbex
  let exarr e = e.exarr
  let noingn e = e.noingn
  let begingn e = e.begingn 
  let endingn e = e.endingn
end 




(* Segmented (Exon) projection. The different exons of an exon projection define 
   elementary segments called Segmented (Exon) projections.
   The property of a segmented projection is that all its nt are included in the same
   number of transcripts.
*)
module SegProj = 
struct
  type t = {
	chrom: string;
	gbeg: int;
	gend: int;
	str: strand;
	score : float;
	exproj: ExonProj.t;
	coverage: int;   (* number of transcripts it belongs to *)
	noinexproj: int; (* number of the segmented projection in the exon projection from the 5' *)
	begingn: int; (* begining of the segmented projection in the virtual cdna of the gene *)
	endingn: int; (* end of the segmented projection in the virtual cdna of the gene *)
	
 }

  let create chr gb ge st sc ep cov no bgn egn = 
    { chrom=chr; gbeg=gb; gend=ge; str=st; score=sc; exproj=ep; coverage=cov; noinexproj=no; begingn=bgn; endingn=egn}
  
  let setcoverage cov s = {s with coverage=cov}
  let setscore sc s = {s with score=sc}

  let chrom s = s.chrom
  let gbeg s = s.gbeg
  let gend s = s.gend
  let str s = s.str
  let score s = s.score
  let exproj s = s.exproj
  let coverage s = s.coverage
  let noinexproj s = s.noinexproj
  let begingn s = s.begingn
  let endingn s = s.endingn
end



